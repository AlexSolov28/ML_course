# -*- coding: utf-8 -*-
"""LAB_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FF8Uu_U_ftHN-PpZ2mmTpriVC4-22Xu6

# Лабораторная работа №4

## Линейные модели, SVM и деревья решений.

### Задание:

1. Выберите набор данных (датасет) для решения задачи классификации или регрессии.
2. В случае необходимости проведите удаление или заполнение пропусков и кодирование категориальных признаков.
3. С использованием метода train_test_split разделите выборку на обучающую и тестовую.
4. Обучите следующие модели:
   * одну из линейных моделей (линейную или полиномиальную регрессию при решении задачи регрессии, логистическую регрессию при решении задачи классификации);
   * SVM;
   * дерево решений.
5. Оцените качество моделей с помощью двух подходящих для задачи метрик. Сравните качество полученных моделей.
6. Постройте график, показывающий важность признаков в дереве решений.
7. Визуализируйте дерево решений или выведите правила дерева решений в текстовом виде.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import SGDClassifier
from sklearn.metrics import f1_score, precision_score
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn.model_selection import GridSearchCV
import matplotlib.pyplot as plt

target_col='class'

# %matplotlib inline
sns.set(style="ticks")

data = pd.read_csv('exams.csv')

data.head()

total_count = data.shape[0]
print('Всего строк: {}'.format(total_count))
total_count = data.shape[1]
print('Всего колонок: {}'.format(total_count))

# Вывод списка колонок с типами данных.
data.dtypes

# Проверка на пропуски
data.isnull().sum()

"""### Кодирование категориальных признаков"""

for col in data.columns:
    null_count = data[data[col].isnull()].shape[0]
    if null_count == 0:
        column_type = data[col].dtype
        print('{} - {} - {}'.format(col, column_type, null_count))

le = LabelEncoder()
for col in data.columns:
    column_type = data[col].dtype
    if column_type == 'object':
        data[col] = le.fit_transform(data[col]);
        print(col)

"""### Разделение выборки на обучающую и тестовую"""

#Построим корреляционную матрицу
fig, ax = plt.subplots(figsize=(15,7))
sns.heatmap(data.corr(method='pearson'), ax=ax, annot=True, fmt='.2f')

X = data[["math score", "reading score"]]
Y = data["writing score"]

X
print('Входные данные:\n', X.head())

Y
print('Выходные данные:\n', Y.head())

pd.DataFrame(X, columns=X.columns).describe()

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.25, random_state=1)
print('{}, {}'.format(X_train.shape, X_test.shape))
print('{}, {}'.format(Y_train.shape, Y_test.shape))

"""### Линейная регрессия"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error,  median_absolute_error, r2_score

Lin_Reg = LinearRegression().fit(X_train, Y_train)
lr_y_pred = Lin_Reg.predict(X_test)

plt.scatter(X_test["reading score"], Y_test,    marker = 's', label = 'Тестовая выборка')
plt.scatter(X_test["reading score"], lr_y_pred, marker = 'o', label = 'Предсказанные данные')
plt.legend (loc = 'lower right')
plt.xlabel ('Баллы по чтению')
plt.ylabel ('Целевой признак')
plt.show()

"""### SVM"""

from sklearn.svm import SVC , LinearSVC
from sklearn.datasets import make_blobs
from matplotlib import pyplot as plt

svc = SVC(kernel='linear')
svc.fit(X_train,Y_train)

pred_y = svc.predict(X_test)

plt.scatter(X_test["reading score"], Y_test,    marker = 's', label = 'Тестовая выборка')
plt.scatter(X_test["reading score"], pred_y, marker = 'o', label = 'Предсказанные данные')
plt.legend (loc = 'lower right')
plt.xlabel ('Баллы по чтению')
plt.ylabel ('Целевой признак')
plt.show()

"""### Дерево решений"""

from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor, export_graphviz
from sklearn.tree import export_graphviz
from sklearn import tree
import re

# Обучим дерево на всех признаках
clf = tree.DecisionTreeClassifier(random_state=1)
clf = clf.fit(X_test, Y_test)
clf

from IPython.core.display import HTML
from sklearn.tree import export_text
tree_rules = export_text(clf, feature_names=list(X.columns))
HTML('<pre>' + tree_rules + '</pre>')



